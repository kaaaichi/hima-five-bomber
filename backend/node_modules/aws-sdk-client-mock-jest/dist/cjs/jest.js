"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const expect_1 = require("expect");
const jestMatchers_1 = require("./jestMatchers");
/**
 * Prettyprints command calls for message
 */
function addCalls(ctxUtils, calls, ...msgs) {
    if (calls.length === 0)
        return msgs.join('\n');
    return [
        ...msgs,
        '',
        'Calls:',
        ...calls.map((c, i) => `  ${i + 1}. ${c.args[0].constructor.name}: ${ctxUtils.printReceived(c.args[0].input)}`),
    ].join('\n');
}
const baseMatchers = (0, jestMatchers_1.createBaseMatchers)({
    toHaveReceivedCommand: ({ client, cmd, notPrefix, calls, commandCalls, ctxUtils, }) => addCalls(ctxUtils, calls, `Expected ${client} to ${notPrefix}receive ${ctxUtils.printExpected(cmd)}`, `${client} received ${ctxUtils.printExpected(cmd)} ${ctxUtils.printReceived(commandCalls.length)} times`),
    toHaveReceivedCommandTimes: (expectedCalls) => ({ calls, client, cmd, commandCalls, notPrefix, ctxUtils }) => addCalls(ctxUtils, calls, `Expected ${client} to ${notPrefix}receive ${ctxUtils.printExpected(cmd)} ${ctxUtils.printExpected(expectedCalls)} times`, `${client} received ${ctxUtils.printExpected(cmd)} ${ctxUtils.printReceived(commandCalls.length)} times`),
    toHaveReceivedCommandWith: (input) => ({ client, cmd, notPrefix, data, calls, ctxUtils }) => addCalls(ctxUtils, calls, `Expected ${client} to ${notPrefix}receive ${ctxUtils.printExpected(cmd)} with ${ctxUtils.printExpected(input)}`, `${client} received matching ${ctxUtils.printExpected(cmd)} ${ctxUtils.printReceived(data.matchCount)} times`),
    toHaveReceivedNthCommandWith: (call, input) => ({ cmd, client, data, notPrefix, ctxUtils, calls }) => addCalls(ctxUtils, calls, `Expected ${client} to ${notPrefix}receive ${call}. ${ctxUtils.printExpected(cmd)} with ${ctxUtils.printExpected(input)}`, ...(data.received
        ? [
            `${client} received ${ctxUtils.printReceived(data.received.constructor.name)} with input:`,
            ctxUtils.printDiffOrStringify(input, data.received.input, 'Expected', 'Received', false),
        ]
        : [])),
    toHaveReceivedNthSpecificCommandWith: (call, input) => ({ cmd, client, data, notPrefix, ctxUtils, calls }) => addCalls(ctxUtils, calls, `Expected ${client} to ${notPrefix}receive ${call}. ${ctxUtils.printExpected(cmd)} with ${ctxUtils.printExpected(input)}`, ...(data.received
        ? [
            `${client} received ${ctxUtils.printReceived(data.received.constructor.name)} with input:`,
            ctxUtils.printDiffOrStringify(input, data.received.input, 'Expected', 'Received', false),
        ]
        : [])),
    toHaveReceivedAnyCommand: ({ client, notPrefix, calls, ctxUtils }) => addCalls(ctxUtils, calls, `Expected ${client} to ${notPrefix}receive any command`, `${client} received any command ${ctxUtils.printReceived(calls.length)} times`),
}, (sample) => expect_1.expect.objectContaining(sample));
/* typing ensures keys matching */
const aliasMatchers = {
    toReceiveCommandTimes: baseMatchers.toHaveReceivedCommandTimes,
    toReceiveCommand: baseMatchers.toHaveReceivedCommand,
    toReceiveCommandWith: baseMatchers.toHaveReceivedCommandWith,
    toReceiveNthCommandWith: baseMatchers.toHaveReceivedNthCommandWith,
    toReceiveNthSpecificCommandWith: baseMatchers.toHaveReceivedNthSpecificCommandWith,
    toReceiveAnyCommand: baseMatchers.toHaveReceivedAnyCommand,
};
// Skip registration if jest expect does not exist
if (typeof expect_1.expect !== 'undefined' && typeof expect_1.expect.extend === 'function') {
    expect_1.expect.extend({ ...baseMatchers, ...aliasMatchers });
}
//# sourceMappingURL=jest.js.map