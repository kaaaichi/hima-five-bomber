import { __assign, __spreadArray } from "tslib";
import { ObjectContaining } from '@vitest/expect';
import { Chalk } from 'chalk';
import { expect } from 'vitest';
import { createBaseMatchers } from './jestMatchers';
export function ordinalOf(n) {
    var j = n % 10;
    var k = n % 100;
    if (j === 1 && k !== 11)
        return "".concat(n, "st");
    if (j === 2 && k !== 12)
        return "".concat(n, "nd");
    if (j === 3 && k !== 13)
        return "".concat(n, "rd");
    return "".concat(n, "th");
}
var chalk = new Chalk({ level: 3 });
var baseMatchers = createBaseMatchers({
    toHaveReceivedCommand: function (_a) {
        var client = _a.client, cmd = _a.cmd, notPrefix = _a.notPrefix;
        return "expected ".concat(client, " to ").concat(notPrefix, "receive ").concat(cmd, " at least once");
    },
    toHaveReceivedCommandTimes: function (expectedCalls) {
        return function (_a) {
            var client = _a.client, cmd = _a.cmd, commandCalls = _a.commandCalls, notPrefix = _a.notPrefix;
            return [
                "expected ".concat(client, " to ").concat(notPrefix, "receive ").concat(cmd, " ").concat(expectedCalls, " times"),
                "but got ".concat(commandCalls.length, " times"),
            ].join(', ');
        };
    },
    toHaveReceivedCommandWith: function (input) {
        return function (_a) {
            var client = _a.client, cmd = _a.cmd, notPrefix = _a.notPrefix, ctxUtils = _a.ctxUtils, commandCalls = _a.commandCalls;
            return __spreadArray(__spreadArray([
                "expected ".concat(client, " to ").concat(notPrefix, "receive ").concat(cmd, " with arguments [").concat(ctxUtils.stringify(input, undefined, { printBasicPrototype: false }), "]"),
                chalk.gray('Received:')
            ], commandCalls.map(function (c, i) {
                var callAnnotation = chalk.gray("  ".concat(ordinalOf(i + 1), " call:"));
                // type of input can not be string, so the return value of `diff` will always be defined
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                var diff = ctxUtils.diff(input, c.args[0].input, { omitAnnotationLines: true, commonColor: chalk.gray });
                return "".concat(callAnnotation, "\n\n").concat(diff);
            }).filter(function (x) { return x; }), true), [
                chalk.gray("Number of calls: ".concat(commandCalls.length)),
            ], false).join('\n\n');
        };
    },
    toHaveReceivedNthCommandWith: function (call, input) {
        return function (_a) {
            var _b;
            var cmd = _a.cmd, client = _a.client, data = _a.data, notPrefix = _a.notPrefix, ctxUtils = _a.ctxUtils, commandCalls = _a.commandCalls;
            var beNthCalled = commandCalls.length >= call;
            var summary = "expected ".concat(client, " to ").concat(notPrefix, "receive ").concat(ordinalOf(call), " ").concat(cmd, " with arguments [").concat(ctxUtils.stringify(input, undefined, { printBasicPrototype: false }), "]");
            var msgWhenNotBeCalled = beNthCalled ? '' : ", but ".concat(client, " has only received ").concat(cmd, " ").concat(commandCalls.length, " times");
            var diff = beNthCalled ? ctxUtils.diff(input, (_b = data.received) === null || _b === void 0 ? void 0 : _b.input, { commonColor: chalk.gray }) : '';
            return [summary + msgWhenNotBeCalled, diff].join('\n\n');
        };
    },
    toHaveReceivedNthSpecificCommandWith: function (call, input) {
        return function (_a) {
            var _b;
            var cmd = _a.cmd, client = _a.client, data = _a.data, notPrefix = _a.notPrefix, ctxUtils = _a.ctxUtils, commandCalls = _a.commandCalls;
            var beNthCalled = commandCalls.length >= call;
            var summary = "expected ".concat(client, " to ").concat(notPrefix, "receive ").concat(ordinalOf(call), " ").concat(cmd, " with arguments [").concat(ctxUtils.stringify(input, undefined, { printBasicPrototype: false }), "]");
            var msgWhenNotBeCalled = beNthCalled ? '' : ", but ".concat(client, " has only received ").concat(cmd, " ").concat(commandCalls.length, " times");
            var diff = beNthCalled ? ctxUtils.diff(input, (_b = data.received) === null || _b === void 0 ? void 0 : _b.input, { commonColor: chalk.gray }) : '';
            return [summary + msgWhenNotBeCalled, diff].join('\n\n');
        };
    },
    toHaveReceivedAnyCommand: function (_a) {
        var client = _a.client, notPrefix = _a.notPrefix;
        return "expected ".concat(client, " to ").concat(notPrefix, "receive any command at least once");
    },
}, function (sample) { return new ObjectContaining(sample); });
var aliasMatchers = {
    toReceiveCommandTimes: baseMatchers.toHaveReceivedCommandTimes,
    toReceiveCommand: baseMatchers.toHaveReceivedCommand,
    toReceiveCommandWith: baseMatchers.toHaveReceivedCommandWith,
    toReceiveNthCommandWith: baseMatchers.toHaveReceivedNthCommandWith,
    toReceiveNthSpecificCommandWith: baseMatchers.toHaveReceivedNthSpecificCommandWith,
    toReceiveAnyCommand: baseMatchers.toHaveReceivedAnyCommand,
};
expect.extend(__assign(__assign({}, baseMatchers), aliasMatchers));
//# sourceMappingURL=vitest.js.map