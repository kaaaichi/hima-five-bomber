import { AwsStub } from 'aws-sdk-client-mock';
import assert from 'node:assert';
function processMatch(args) {
    var ctx = args.ctx, mockClient = args.mockClient, command = args.command, check = args.check, message = args.message;
    assert(mockClient instanceof AwsStub, 'The actual must be a client mock instance');
    if (command) {
        assert(typeof command === 'function' &&
            typeof command.name === 'string' &&
            command.name.length > 0, 'Command must be valid AWS SDK Command');
    }
    var calls = mockClient.calls();
    var commandCalls = command ? mockClient.commandCalls(command) : [];
    var _a = check({ calls: calls, commandCalls: commandCalls }), pass = _a.pass, data = _a.data;
    var msg = function () {
        var _a;
        var cmd = (_a = command === null || command === void 0 ? void 0 : command.name) !== null && _a !== void 0 ? _a : 'Any Command';
        var client = mockClient.clientName();
        return message({
            client: client,
            cmd: cmd,
            data: data,
            calls: calls,
            commandCalls: commandCalls,
            notPrefix: ctx.isNot ? 'not ' : '',
            ctxUtils: ctx.utils,
        });
    };
    return { pass: pass, message: msg };
}
var ensureNoOtherArgs = function (args) {
    assert(args.length === 0, 'Too many matcher arguments');
};
export function createBaseMatchers(errorMsg, objectContaining) {
    return {
        toHaveReceivedCommand: function (mockClient, command) {
            var other = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                other[_i - 2] = arguments[_i];
            }
            ensureNoOtherArgs(other);
            return processMatch({
                ctx: this,
                mockClient: mockClient,
                command: command,
                check: function (_a) {
                    var commandCalls = _a.commandCalls;
                    return ({
                        pass: commandCalls.length > 0,
                        data: undefined,
                    });
                },
                message: errorMsg.toHaveReceivedCommand,
            });
        },
        toHaveReceivedCommandTimes: function (mockClient, command, expectedCalls) {
            var other = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                other[_i - 3] = arguments[_i];
            }
            ensureNoOtherArgs(other);
            return processMatch({
                ctx: this,
                mockClient: mockClient,
                command: command,
                check: function (_a) {
                    var commandCalls = _a.commandCalls;
                    return ({
                        pass: commandCalls.length === expectedCalls,
                        data: undefined,
                    });
                },
                message: errorMsg.toHaveReceivedCommandTimes(expectedCalls),
            });
        },
        toHaveReceivedCommandWith: function (mockClient, command, input) {
            var other = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                other[_i - 3] = arguments[_i];
            }
            ensureNoOtherArgs(other);
            return processMatch({
                ctx: this,
                mockClient: mockClient,
                command: command,
                check: function (_a) {
                    var commandCalls = _a.commandCalls;
                    var matchCount = commandCalls
                        .map(function (call) { return call.args[0].input; }) // eslint-disable-line @typescript-eslint/no-unsafe-return
                        .map(function (received) { return objectContaining(input).asymmetricMatch(received); })
                        .reduce(function (acc, val) { return acc + Number(val); }, 0);
                    return { pass: matchCount > 0, data: { matchCount: matchCount } };
                },
                message: errorMsg.toHaveReceivedCommandWith(input),
            });
        },
        toHaveReceivedNthCommandWith: function (mockClient, call, command, input) {
            var other = [];
            for (var _i = 4; _i < arguments.length; _i++) {
                other[_i - 4] = arguments[_i];
            }
            ensureNoOtherArgs(other);
            assert(call && typeof call === 'number' && call > 0, 'Call number must be a number greater than 0');
            return processMatch({
                ctx: this,
                mockClient: mockClient,
                command: command,
                check: function (_a) {
                    var calls = _a.calls;
                    if (calls.length < call) {
                        return { pass: false, data: { received: undefined } };
                    }
                    var received = calls[call - 1].args[0];
                    var pass = false;
                    if (received instanceof command) {
                        pass = objectContaining(input).asymmetricMatch(received.input);
                    }
                    return {
                        pass: pass,
                        data: { received: received },
                    };
                },
                message: errorMsg.toHaveReceivedNthCommandWith(call, input),
            });
        },
        toHaveReceivedNthSpecificCommandWith: function (mockClient, call, command, input) {
            var other = [];
            for (var _i = 4; _i < arguments.length; _i++) {
                other[_i - 4] = arguments[_i];
            }
            ensureNoOtherArgs(other);
            assert(call && typeof call === 'number' && call > 0, 'Call number must be a number greater than 0');
            return processMatch({
                ctx: this,
                mockClient: mockClient,
                command: command,
                check: function (_a) {
                    var commandCalls = _a.commandCalls;
                    if (commandCalls.length < call) {
                        return { pass: false, data: { received: undefined } };
                    }
                    var received = commandCalls[call - 1].args[0];
                    var pass = false;
                    if (received instanceof command) {
                        pass = objectContaining(input).asymmetricMatch(received.input);
                    }
                    return {
                        pass: pass,
                        data: { received: received },
                    };
                },
                message: errorMsg.toHaveReceivedNthSpecificCommandWith(call, input),
            });
        },
        toHaveReceivedAnyCommand: function (mockClient) {
            var other = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                other[_i - 1] = arguments[_i];
            }
            ensureNoOtherArgs(other);
            return processMatch({
                ctx: this,
                mockClient: mockClient,
                check: function (_a) {
                    var calls = _a.calls;
                    return ({ pass: calls.length > 0, data: undefined });
                },
                message: errorMsg.toHaveReceivedAnyCommand,
            });
        },
    };
}
//# sourceMappingURL=jestMatchers.js.map